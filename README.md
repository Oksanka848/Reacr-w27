# React-w27

*1. Как вы думаете, чем плохо задание атрибута компонента `key` функцией Math.random()?*

Нестабильные ключи (например, созданные Math.random()) вызовут ненужное воссоздание многих экземпляров компонентов и узлов DOM,
что может вызвать снижение производительности и потерю состояния дочерних компонентов.

*2. Как будет выглядеть [этот](https://www.notion.so/34-cfc2f2ef8a0b4650a43db2d7f9c570df) пример, если мы кроме id будем передавать еще один параметр title?*

```
class Component extends React.Component {
    constructor(props) {
        super(props);
        this.state = { count: 0 };
    }
    onClick = ({id, title}, e) => {
        console.log('Действие на строке ' + id + title);
        e.preventDefault();
        this.setState({ count: this.state.count + 1 });
    };
     render() {
        const {id} = this.props;
        const {title} = this.props;
        const {count} = this.state;
        return <a href="#" data-id={id} data-title={title} onClick={this.onClick}>click {count}</a>;
    }
}
```
*3. В чем отличие VirtualDOM от обычного DOM?*

Отличается производительностью, не имеет официальной спецификации, что делает его более гибким для изменений, учитывая лишь изменения, которые мы вносим

*4. В каком порядке выйдут сообщения в консоли и почему?*

    ```
    handleChange = () => {
    	console.log('foo');
    	this.setState({
    		checked: !this.state.checked,
    		},
    		()=>{console.log('baz')}
    	);
    	console.log('bar')
    };
    ```
  В консоли выведется  foo, bar, baz. , т.к. функция setState является асинхронной, не меняет состояние напрямую, и ее действие будет отложенным.

*5. Какую проблему решает использование рефов?*

Использование рефов позволяет императивно изменить дочерний элемент, обойдя обычный поток данных. 

*6. Как вы думаете почему вызов методов ребенка из родительского компонента противоречит философии реакта?*

Одной из основных философий реакта является концепция однонаправленного нисходящего потока данных, где состояние всегда принадлежит определённому компоненту,
а любые производные этого состояния могут влиять только на компоненты, находящиеся «ниже» в дереве компонентов.
Поэтому вызов методов ребенка из родительского компонента противоречит философии реакта.

*7. Можно ли с помощью хука `useRef` передать `ref` дочерним элементам?*

можно

*8. Что дает нам использование кастомных хуков?*

снижение сложности кода (облегчает его, повышает скорость загрузки), повышения удобства повторного использования логики с отслеживанием состояния
